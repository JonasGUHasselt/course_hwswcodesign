[
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/100_processor/",
	"title": "1 Processor",
	"tags": [],
	"description": "",
	"content": " Processor Image courtesy: Pexels - Pok Rie   div.image_courtesy { text-align: center; font-size: 100%; font-style: italic; }  test\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/100_processor/101_processor/",
	"title": "101 - Processor",
	"tags": [],
	"description": "",
	"content": "Hello world !!\nEvery computer(-like) system has a processor at the heart of its system. Throughout this program you have encountered a number of them already, in different sizes and with different capabilities. There was the Arduino in 2Ba which has an 8-bit Atmel AVR controller; the (most recent version of) SoC-lab course uses the 32-bit soft-core MicroBlaze processor; and (without being able to give the specs) there is of course the processor in your laptop.\nIn this course, the techniques of hardware-software codesign are explored.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/100_processor/102_riscv/",
	"title": "102 - RISC-V",
	"tags": [],
	"description": "",
	"content": " As you know by know, computers speak a different language than us, humans. Also, different computers don\u0026rsquo;t speak the same language, although some similarities can be detected. Where all our words in the English or Dutch language are nicely summarised in a dictionary. Similarly, the words that a processor speaks are summarised in an instruction set.\nWhen we hear stories, from a certain level of abstraction these stories are simply a collection of words that occur in the dictionary. This concept also translates to a processor in the form of a program. A program is set of instructions put in a specific order to tell a story, or achieve a certain functionality.\nTo interpret and execute a program, an architecture is needed. Such a computer architecture is a model on how the list of instructions should be executed. A frequently used instruction set architecture (ISA) is the load-store architecture. This technique is used by the PowerPC, a MIPS processor, an ARM core \u0026hellip; and the RISC-V. Another famous ISA is the register-memory architecture. This is used by the Intel x86 and the Motorola 68000 series.\nThe difference between a load-store architecture and a register-memory architecture can be illustrated using an example: add a, b, c. This instruction has the processor calculate the sum of b and c and places the result in a. In a load-store architecture all three locations (a, b, and c) must be residing in a register. In a register-memory architecture these locations can also reside in memory.\nIn 2011 the University of California, Berkely published the RISC-V Instruction Set Manual. The full history of RISC-V can be found on their website. This original specification has undergone quite some change. The most recent version (at the moment of writing) is December 16, 2021 and can be found here. Finally it is pointed out that RISC-V ISA is completely open and freely available to academia and industry ðŸ˜ƒ.\nA word from the instruction set is (for this course) assumed to be 32 bits. Such a 32-bit word can mean anything in the world until a consensus is achieved on how to interpret these words. This is done in the RISC-V ISA and will be shortly (re-)visit below.\nHaving any idea, like the RISC-V, on paper is an important step. Of course, even the best design on paper is not running any programs. An implementation of the described ideas has to be made. For this course an existing implementation of RISC-V will used: the PicoRV32. This implementation is a hardware description of a RISC-V processor and is optimised for size.\nRISC-V instruction formats The core instructions in RISC-V can be grouped in 6 different formats:\n R-format: these are instructions with 3 register inputs I-format: these are instructions with immediates and loads S-format: these are store instructions SB-format: these are branch instructions U-format: these are store instructions wit hupper immediates UJ-format: these are jump instructions   Depending on the format of the instruction, it should be interpreted differently.  \nRISC-V instruction sub-sets Although there are many instructions defined in the instruction set, different subsets are made. The base instruction set exists in 3 different sizes: 32, 64 and 128 bits. These are named RV32I,RV64I, and RV128I respectively. In the 64-bit subset, registers are 64 bits wide; and the 128-bit subset increases this even to 128 bits. The need for the latter is debatable (and out of scope here). The base instructions sets all support instructions for basic integer operations. In the I variant there are 32 registers while in the E variant only 16 registers are required.\nDifferent extensions are also proposed.\n M: Instructions for multiplication and division C: Compact instructions that have only 16-bit encoding. This extension is very important for applications requiring low memory footprint. F: Single-precision floating-point instructions D: Double-precision floating-point instructions A: Atomic memory instructions B: Bit manipulation instructions. The extension contains instructions used for bit manipulations, such as rotations or bit set/clear instructions. V: Vector instructions that can be used for HPC. P: DSP and packed SIMD instructions needed for embedded DSP processors.  The naming of the instruction sub-set hence defines what should be supported by the architecture and the implementation; for example: an RV64IM, or a RV32IMFB.\nFrom the README-file in the GitHub repository of the PicoRV can be read:\n PicoRV32 is a CPU core that implements the RISC-V RV32IMC Instruction Set. It can be configured as RV32E, RV32I, RV32IC, RV32IM, or RV32IMC core, and optionally contains a built-in interrupt controller.\n This means that all the configurations are 32-bit implementations that have 32 or 16 registers. Also the required base instruction set is present, and there are options to also enable the multiplication and division instructions; and (as the name suggests) there is an option for having compact instructions.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/100_processor/103_picorv/",
	"title": "103 - PicoRV32",
	"tags": [],
	"description": "",
	"content": " RISC-V is not a processor, but a specification. Of course there is the Internet and plenty of people have made an implementation for this specification. In this course we\u0026rsquo;ll be working with the PicoRV32. The entity (or module) looks like the image below.\nNative memory interface The PicoRV32 has a simple memory interface. It allows for a single memory transfer at a time. Every transaction is initiated by the PicoRV32 core, by raising mem_valid. The receiving peer will acknowledge the request through mem_ready.\nA normal memory transfer\u0026rsquo;s handshake.\n An instruction memory transfer\u0026rsquo;s handshake.\n \nA standard read transfer Upon doing a read transfer mem_wdata is not used and mem_wstrb is fixed at 0x0. The address of which the data is requested is presented at mem_addr. The data that is read is presented back at the PicoRV32 through the mem_rdata bus and is valid simultaneously with mem_ready.  A standard write transfer Upon doing a write transfer mem_rdata is not used and mem_wstrb must be used. The address at which the data is to written is presented at mem_addr. Simultaneously, the mem_wdata presents the value to be stored. The operation is acknowledged by the peer through mem_ready. The mem_wstrb bus indicates which bytes in the 32-bit word are valid.\nNote that not all 16 possible values for mem_wstrb are allowed. Only these values are valid: 0000, 1111, 1100, 0011, 1000, 0100, 0010, and 0001.\n \n\nBoth for the read and write transfers there is no need for a waiting cycle. If the peer (memory) acknowledges, work can continue. Finally, the PicoRV32 core also provides a Look-Ahead Memory Interface that provides all information about the next memory transfer one clock cycle earlier than the normal interface.\nIn the clock cycle before mem_valid goes high, this interface will output a pulse on mem_la_read or mem_la_write to indicate the start of a read or write transaction in the next clock cycle.\nThe signals mem_la_read, mem_la_write, and mem_la_addr are driven by combinatorial circuits within the PicoRV32 core. It might be harder to achieve timing closure with the look-ahead interface than with the normal memory interface described above.\n Interrupts The PicoRV32 can be enabled to use interrupts through the parameter ENABLE_IRQ. The build-in interrupt controller supports 32 interrupt inputs (IRQ) which are acknowledged by the PicoRV32 through the end-of-interrupt (eoi) signal.\nThe IRQ handling features in PicoRV32 do not follow the RISC-V Privileged ISA specification. Instead a small set of very simple custom instructions is used to implement IRQ handling with minimal hardware overhead.\n Pico Co-Processor Interface (PCPI) The co-processor interface will be discussed in detail in the next chapter.\n\u0026nbsp;\n -- Simulation Simply creating a Vivado project with the code from the PicoRV32 GitHub repository allows you to run a simulation. As can be seen from the waveforms below, the core starts reading from address 0x0. By default (if no instruction dictates otherwise) the program counter is incremented with 0x4 after every instruction.\nThe reason for incrementing the address with 4 instead of 1 lies in addressability of bytes. As every address points to a 32-bit word, the smallest unit would be 32 bits. However, sometimes only one byte is targeted. Selecting offsets within a 32-bit word can thus be provided.\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/100_processor/104_crosscomp/",
	"title": "104 - Cross compiling",
	"tags": [],
	"description": "",
	"content": " To make a program run on the PicoRV32, it has to be written first. The software that is written in this course will be in C. Of course, the processor does not understand C instructions. As you have seen in earlier courses, the C-code is first compiled and then linked to end up with a binary. This binary contains machine code that can be ran on the processor.\nIf the machine on which the compiler and linker are executed differs from the target machine that is to execute the program, the term cross-compilation is used.\nAll examples in this course were compiled with the riscv32-unknown-elf-gcc. For more information on installing this toolchain please use Google (e.g. here).\nBare metal Bare metal programming is writing software that is not running on an Operating System (OS). You probably have done this when (maybe unknowingly) programming an Arduino or another microprocessor.\nfirmware.c  #include \u0026#34;print.h\u0026#34; void main(void) { print_str(\u0026#34;hello world\\n\u0026#34;); } \nThe simplest (but still traditional) code that you can imagine is shown here: a simple print of the string hello word. Even with 4 lines of code 2 things should be highlighted.First of all, no include of stdio.h is done, but \u0026ldquo;print.h\u0026rdquo; is included. And secondly, the printing function is print_str() contrary to the traditional printf().\n\n\nAs there is no operating system, we have no access to functions other than to those that we write ourselves. Luckily the repository of the PicoRV32 provides example print functionality. With the include of firmware.h two basic header files are included and 4 forward declarations are done.\nprint.h  // This is free and unencumbered software released into the // public domain. Anyone is free to copy, modify, publish, // use, compile, sell, or distribute this software, either // in source code form or as a compiled binary, for any // purpose, commercial or non-commercial, and by any means.  #ifndef FIRMWARE_H #define FIRMWARE_H  #include \u0026lt;stdint.h\u0026gt;#include \u0026lt;stdbool.h\u0026gt; // print.c void print_chr(char ch); void print_str(const char *p); void print_dec(unsigned int val); void print_hex(unsigned int val, int digits); #endif With these four functions, there is an opportunity to print a character, a string (as in a list of characters), a decimal value, or a hexadecimal value. A logical question would be: \u0026ldquo;Where is my character (or other variable) printed ?\u0026rdquo;. The answer lies in this line: ((volatile uint32_t)OUTPORT) = ch;\nLetâ€™s break this down for those whose C-skills are a bit rusty. The define OUTPORT makes sure that, everywhere in the code this define is substituted by the 32-bit number 0x10000000. This value is type-cast to an unsigned 32-bit pointer((volatile uint32_t*)). The keyword volatile states that the content of a variable can also be altered from another source. This is important !! Otherwise the optimisation of the C-compiler might optimise-out certain lines of C-code. Finally, that address is dereferenced to target *the memory that is located at address 0x10000000.\n\nprint.c  // This is free and unencumbered software released into the // public domain. Anyone is free to copy, modify, publish, // use, compile, sell, or distribute this software, either // in source code form or as a compiled binary, for any // purpose, commercial or non-commercial, and by any means.  #include \u0026#34;print.h\u0026#34; #define OUTPORT 0x10000000  void print_chr(char ch) { *((volatile uint32_t*)OUTPORT) = ch; } void print_str(const char *p) { while (*p != 0) *((volatile uint32_t*)OUTPORT) = *(p++); } void print_dec(unsigned int val) { char buffer[10]; char *p = buffer; while (val || p == buffer) { *(p++) = val % 10; val = val / 10; } while (p != buffer) { *((volatile uint32_t*)OUTPORT) = \u0026#39;0\u0026#39; + *(--p); } print_chr(\u0026#39;\\n\u0026#39;); } void print_hex(unsigned int val, int digits) { for (int i = (4*digits)-4; i \u0026gt;= 0; i -= 4) *((volatile uint32_t*)OUTPORT) = \\ \u0026#34;0123456789ABCDEF\u0026#34;[(val \u0026gt;\u0026gt; i) % 16]; print_chr(\u0026#39;\\n\u0026#39;); } \n\nTypically, the one function that has to be present in every C-program is the main() function. This function is called by the OS to start of the program. As in bare metal programming there is no OS, some form of booting-process needs to be defined. The PicoRV32 comes with an example assembly filethat can be simplified to the script below.\nstart.S  .section .init .global main start: /* zero-initialize all registers */ addi x1, zero, 0 addi x2, zero, 0 addi x3, zero, 0 addi x4, zero, 0 addi x5, zero, 0 addi x6, zero, 0 addi x7, zero, 0 addi x8, zero, 0 addi x9, zero, 0 addi x10, zero, 0 addi x11, zero, 0 addi x12, zero, 0 addi x13, zero, 0 addi x14, zero, 0 addi x15, zero, 0 addi x16, zero, 0 addi x17, zero, 0 addi x18, zero, 0 addi x19, zero, 0 addi x20, zero, 0 addi x21, zero, 0 addi x22, zero, 0 addi x23, zero, 0 addi x24, zero, 0 addi x25, zero, 0 addi x26, zero, 0 addi x27, zero, 0 addi x28, zero, 0 addi x29, zero, 0 addi x30, zero, 0 addi x31, zero, 0 /* set stack pointer */ lui sp, %hi(16*1024) addi sp, sp, %lo(16*1024) /* call main */ jal ra, main /* break - trap */ ebreak \nfirmware.lds \nSECTIONS { .memory : { . = 0x000000; (.init); (.text); (); . = ALIGN(4); end = .; } } This assembly code will be executed first because it is mapped first in the memory space through the linker script (firmware.lds). The assembly file defines there is a label main and then starts of with start label.\nThis start function sets all the registers of the processor to 0x0, it will load the stack pointer register to its maximum value. Then, the main() function is called. After the main function has finished, an ebreak command is execute which will have the PicoRV32 halt and raise the trap signal.\n\n\nWith these 5 files (1 header, 3 C files and a linker script) the final binary file can be generated. This binary is in the Executable and Linkable Format (.elf)\nConversion to human-readable and to FPGA-compatible After running the tool chain, an .elf file is generated. It might become useful to understand what is going on in this file (as humans). Secondly, this file needs to be loaded to the FPGA implementation of the RISC-V.\n\u0026hellip; to human-readable The generated binary file can be disassembled again. Doing this allows us to read what was eventually generated by the compiler. The riscv32-toolbox comes with a program riscv32-unknown-elf-objdump. This can be used to achieve a disassembly by using the -D option.\nAn option to generate this file is present in the Makefile and the result should look something like this.\nfirmware.objdump \nfirmware.elf: file format elf32-littleriscv\nDisassembly of section .memory:\n00000000 \u0026lt;start\u0026gt;: 0: 00000093 li ra,0 4: 00000113 li sp,0 8: 00000193 li gp,0 c: 00000213 li tp,0 10: 00000293 li t0,0 14: 00000313 li t1,0 18: 00000393 li t2,0 1c: 00000413 li s0,0 20: 00000493 li s1,0 24: 00000513 li a0,0 28: 00000593 li a1,0 2c: 00000613 li a2,0 30: 00000693 li a3,0 34: 00000713 li a4,0 38: 00000793 li a5,0 3c: 00000813 li a6,0 40: 00000893 li a7,0 44: 00000913 li s2,0 48: 00000993 li s3,0 4c: 00000a13 li s4,0 50: 00000a93 li s5,0 54: 00000b13 li s6,0 58: 00000b93 li s7,0 5c: 00000c13 li s8,0 60: 00000c93 li s9,0 64: 00000d13 li s10,0 68: 00000d93 li s11,0 6c: 00000e13 li t3,0 70: 00000e93 li t4,0 74: 00000f13 li t5,0 78: 00000f93 li t6,0 7c: 00004137 lui sp,0x4 80: 00010113 mv sp,sp 84: 1c8000ef jal ra,24c \u0026lt;main\u0026gt; 88: 00100073 ebreak\n0000008c \u0026lt;esns_nop\u0026gt;: 8c: 00000013 nop 90: 00008067 ret\n00000094 \u0026lt;print_chr\u0026gt;: 94: 100007b7 lui a5,0x10000 98: 00a7a023 sw a0,0(a5) # 10000000 \u0026lt;end+0xffffd98\u0026gt; 9c: 00008067 ret\n000000a0 \u0026lt;print_str\u0026gt;: a0: 10000737 lui a4,0x10000 a4: 00054783 lbu a5,0(a0) a8: 00079463 bnez a5,b0 \u0026lt;print_str+0x10\u0026gt; ac: 00008067 ret b0: 00150513 addi a0,a0,1 b4: 00f72023 sw a5,0(a4) # 10000000 \u0026lt;end+0xffffd98\u0026gt; b8: fedff06f j a4 \u0026lt;print_str+0x4\u0026gt;\n000000bc \u0026lt;print_dec\u0026gt;: bc: fe010113 addi sp,sp,-32 # 3fe0 \u0026lt;end+0x3d78\u0026gt; c0: 00812c23 sw s0,24(sp) c4: 00410413 addi s0,sp,4 c8: 00912a23 sw s1,20(sp) cc: 01212823 sw s2,16(sp) d0: 00112e23 sw ra,28(sp) d4: 00050493 mv s1,a0 d8: 00040913 mv s2,s0 dc: 02049c63 bnez s1,114 \u0026lt;print_dec+0x58\u0026gt; e0: 03240a63 beq s0,s2,114 \u0026lt;print_dec+0x58\u0026gt; e4: 10000737 lui a4,0x10000 e8: fff40413 addi s0,s0,-1 ec: 00044783 lbu a5,0(s0) f0: 03078793 addi a5,a5,48 f4: 00f72023 sw a5,0(a4) # 10000000 \u0026lt;end+0xffffd98\u0026gt; f8: ff2418e3 bne s0,s2,e8 \u0026lt;print_dec+0x2c\u0026gt; fc: 01c12083 lw ra,28(sp) 100: 01812403 lw s0,24(sp) 104: 01412483 lw s1,20(sp) 108: 01012903 lw s2,16(sp) 10c: 02010113 addi sp,sp,32 110: 00008067 ret 114: 00a00593 li a1,10 118: 00048513 mv a0,s1 11c: 0a8000ef jal ra,1c4 \u0026lt;umodsi3\u0026gt; 120: 00140413 addi s0,s0,1 124: fea40fa3 sb a0,-1(s0) 128: 00a00593 li a1,10 12c: 00048513 mv a0,s1 130: 04c000ef jal ra,17c \u0026lt;udivsi3\u0026gt; 134: 00050493 mv s1,a0 138: fa5ff06f j dc \u0026lt;print_dec+0x20\u0026gt;\n0000013c \u0026lt;print_hex\u0026gt;: 13c: fff58593 addi a1,a1,-1 140: 00000737 lui a4,0x0 144: 00259593 slli a1,a1,0x2 148: 22870713 addi a4,a4,552 # 228 \u0026lt;__modsi3+0x30\u0026gt; 14c: 100006b7 lui a3,0x10000 150: 0005d463 bgez a1,158 \u0026lt;print_hex+0x1c\u0026gt; 154: 00008067 ret 158: 00b557b3 srl a5,a0,a1 15c: 00f7f793 andi a5,a5,15 160: 00e787b3 add a5,a5,a4 164: 0007c783 lbu a5,0(a5) 168: ffc58593 addi a1,a1,-4 16c: 00f6a023 sw a5,0(a3) # 10000000 \u0026lt;end+0xffffd98\u0026gt; 170: fe1ff06f j 150 \u0026lt;print_hex+0x14\u0026gt;\n00000174 \u0026lt;divsi3\u0026gt;: 174: 06054063 bltz a0,1d4 \u0026lt;umodsi3+0x10\u0026gt; 178: 0605c663 bltz a1,1e4 \u0026lt;__umodsi3+0x20\u0026gt;\n0000017c \u0026lt;udivsi3\u0026gt;: 17c: 00058613 mv a2,a1 180: 00050593 mv a1,a0 184: fff00513 li a0,-1 188: 02060c63 beqz a2,1c0 \u0026lt;udivsi3+0x44\u0026gt; 18c: 00100693 li a3,1 190: 00b67a63 bgeu a2,a1,1a4 \u0026lt;udivsi3+0x28\u0026gt; 194: 00c05863 blez a2,1a4 \u0026lt;udivsi3+0x28\u0026gt; 198: 00161613 slli a2,a2,0x1 19c: 00169693 slli a3,a3,0x1 1a0: feb66ae3 bltu a2,a1,194 \u0026lt;udivsi3+0x18\u0026gt; 1a4: 00000513 li a0,0 1a8: 00c5e663 bltu a1,a2,1b4 \u0026lt;udivsi3+0x38\u0026gt; 1ac: 40c585b3 sub a1,a1,a2 1b0: 00d56533 or a0,a0,a3 1b4: 0016d693 srli a3,a3,0x1 1b8: 00165613 srli a2,a2,0x1 1bc: fe0696e3 bnez a3,1a8 \u0026lt;__udivsi3+0x2c\u0026gt; 1c0: 00008067 ret\n000001c4 \u0026lt;umodsi3\u0026gt;: 1c4: 00008293 mv t0,ra 1c8: fb5ff0ef jal ra,17c \u0026lt;udivsi3\u0026gt; 1cc: 00058513 mv a0,a1 1d0: 00028067 jr t0 1d4: 40a00533 neg a0,a0 1d8: 0005d863 bgez a1,1e8 \u0026lt;umodsi3+0x24\u0026gt; 1dc: 40b005b3 neg a1,a1 1e0: f9dff06f j 17c \u0026lt;udivsi3\u0026gt; 1e4: 40b005b3 neg a1,a1 1e8: 00008293 mv t0,ra 1ec: f91ff0ef jal ra,17c \u0026lt;__udivsi3\u0026gt; 1f0: 40a00533 neg a0,a0 1f4: 00028067 jr t0\n000001f8 \u0026lt;modsi3\u0026gt;: 1f8: 00008293 mv t0,ra 1fc: 0005ca63 bltz a1,210 \u0026lt;modsi3+0x18\u0026gt; 200: 00054c63 bltz a0,218 \u0026lt;modsi3+0x20\u0026gt; 204: f79ff0ef jal ra,17c \u0026lt;udivsi3\u0026gt; 208: 00058513 mv a0,a1 20c: 00028067 jr t0 210: 40b005b3 neg a1,a1 214: fe0558e3 bgez a0,204 \u0026lt;modsi3+0xc\u0026gt; 218: 40a00533 neg a0,a0 21c: f61ff0ef jal ra,17c \u0026lt;udivsi3\u0026gt; 220: 40b00533 neg a0,a1 224: 00028067 jr t0 228: 3130 fld fa2,96(a0) 22a: 3332 fld ft6,296(sp) 22c: 3534 fld fa3,104(a0) 22e: 3736 fld fa4,360(sp) 230: 3938 fld fa4,112(a0) 232: 4241 li tp,16 234: 46454443 fmadd.q fs0,fa0,ft4,fs0,rmm 238: 4700 lw s0,8(a4) 23a: 203a4343 fmadd.s ft6,fs4,ft3,ft4,rmm 23e: 4728 lw a0,72(a4) 240: 554e lw a0,240(sp) 242: 2029 jal 24c \u0026lt;main\u0026gt; 244: 2e38 fld fa4,88(a2) 246: 2e32 fld ft8,264(sp) 248: 0030 addi a2,sp,8 \u0026hellip;\n0000024c \u0026lt;main\u0026gt;: 24c: 00000537 lui a0,0x0 250: 25850513 addi a0,a0,600 # 258 \u0026lt;main+0xc\u0026gt; 254: e4dff06f j a0 \u0026lt;print_str\u0026gt; 258: 6568 flw fa0,76(a0) 25a: 6c6c flw fa1,92(s0) 25c: 6f77206f j 73152 \u0026lt;end+0x72eea\u0026gt; 260: 6c72 flw fs8,28(sp) 262: 0a64 addi s1,sp,284 264: 0000 unimp \u0026hellip;\n \u0026hellip; to human-readable Next to \u0026lsquo;decompiling\u0026rsquo; the binary .elf file to a human-readable it can also be translated to a flat text format. This can be achieved with a Python script makehex.py.\nAn option to generate this hex dump is present in the Makefile and the result should look something like this.\nfirmware.hex  00000093 00000113 00000193 00000213 00000293 00000313 00000393 00000413 00000493 00000513 00000593 00000613 00000693 00000713 00000793 00000813 00000893 00000913 00000993 00000a13 00000a93 00000b13 00000b93 00000c13 00000c93 00000d13 00000d93 00000e13 00000e93 00000f13 00000f93 00004137 00010113 1c8000ef 00100073 00000013 00008067 100007b7 00a7a023 00008067 10000737 00054783 00079463 00008067 00150513 00f72023 fedff06f fe010113 00812c23 00410413 00912a23 01212823 00112e23 00050493 00040913 02049c63 03240a63 10000737 fff40413 00044783 03078793 00f72023 ff2418e3 01c12083 01812403 01412483 01012903 02010113 00008067 00a00593 00048513 0a8000ef 00140413 fea40fa3 00a00593 00048513 04c000ef 00050493 fa5ff06f fff58593 00000737 00259593 22870713 100006b7 0005d463 00008067 00b557b3 00f7f793 00e787b3 0007c783 ffc58593 00f6a023 fe1ff06f 06054063 0605c663 00058613 00050593 fff00513 02060c63 00100693 00b67a63 00c05863 00161613 00169693 feb66ae3 00000513 00c5e663 40c585b3 00d56533 0016d693 00165613 fe0696e3 00008067 00008293 fb5ff0ef 00058513 00028067 40a00533 0005d863 40b005b3 f9dff06f 40b005b3 00008293 f91ff0ef 40a00533 00028067 00008293 0005ca63 00054c63 f79ff0ef 00058513 00028067 40b005b3 fe0558e3 40a00533 f61ff0ef 40b00533 00028067 33323130 37363534 42413938 46454443 43434700 4728203a 2029554e 2e322e38 00000030 00000537 25850513 e4dff06f 6c6c6568 6f77206f 0a646c72 00000000 \n\nOverall toolflow   \n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/100_processor/105_simulation/",
	"title": "105 - Simulation",
	"tags": [],
	"description": "",
	"content": "  By now you should have a Vivado project that is able to simulate the PicoRV. Also, you should have a working setup that compiles C-code into a .hex file. It\u0026rsquo;s time to close this loop.\nIn the depicted testbench sits the PicoRV32 in the center. This device-under-test (DUT) is the unmodified code from the PicoRV32 repo.\nAs there currently is no implementation for the memory, the testbench instantiates a model (picorv_mem_model.vhd) that mimics the behaviour of such a memory implementation.\nThis approach is similar to how you modelled a clock source.\nThe picorv_mem_model has an additional input load_file. With this input set, the model reads in a file into it\u0026rsquo;s virtual memory.\nIn the previous section it was discussed how the result of a print function ended up in a write to address 0x10000000. This is also caught by this memory model. Every write to this address hence results in a write to file, e.g. output.dat.\n \nBoth the filenames of the input file and the output file are set through generics:\n... picorv_mem_model_inst00: component picorv_mem_model generic map ( G_DATA_WIDTH =\u0026gt; G_DATA_WIDTH, FNAME_HEX =\u0026gt; \u0026#34;/home/jvliegen/vc/github/KULeuven-Diepenbeek/hwswcodedign-course/src/firmware/example1/firmware.hex\u0026#34;, FNAME_OUT =\u0026gt; \u0026#34;/home/jvliegen/vc/github/KULeuven-Diepenbeek/hwswcodedign-course/src/firmware/example1/simulation_output.dat\u0026#34; ) port map ( ... ); ... Please note that the possibility of describing such models is an intrinsic part of the HDL. However, it is still important to understand that this type of code is non-synthesisable, as in \u0026hellip; it can not be translated to hardware components.\nParsing the output A simple Python script is available to \u0026lsquo;parse\u0026rsquo; the output that is generated by the memory model:\n python3 tools/parse_simulation.py \u0026lt;simulation_output_filename\u0026gt;\n This script converts the 32-bit binary string to an integer and shows it both decimally and hexa-decimally. Also the corresponding character is printed.\nFeel free to adjust/upgrade/improve/\u0026hellip; this parsing script !!\n \n\n\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/100_processor/106_exercises/",
	"title": "106 - Exercises",
	"tags": [],
	"description": "",
	"content": " Below are a number of programming exercises. The aim is that you 1) prepare a working setup, and 2) that you refresh you low-level C programming skills. In the exercises where inputs are required, these inputs can be hardcoded as we have no means of inputting data to the processor.\nExercise 101 For this exercise you should simply try to get the examples of this chapter to work.  create a Vivado project import the picorv32.v description  import the testbench and the memory model generate the .hex file run the simulation parse the output  As FPGA device, you can pick a ZYNQ XC7Z020-1CLG400C. An even better solution is to pick the PYNQ-Z2 board in case you have the board drivers installed.  Exercise 102 For this exercise you will re-organise the memory map. In stead of writing all output to 0x10000000 to the file, update the design so it writes all output to 0x80000000 to the file.  Exercise 103 Write a firmware function get_hamming_weight() that can calculate the Hamming weight of a value. Print the Hamming weight to the output. unsigned int get_hamming_weight(unsigned int x); Determine how long it takes (in clock cycles) to perform the calculation !!\n\nExercise 104 Write a firmware function get_hamming_distance() that can calculate the Hamming distance between two values. Print the Hamming distance to the output. unsigned int get_hamming_distance(unsigned int x, unsigned int y); Determine how long it takes (in clock cycles) to perform the calculation !!\n\nExercise 105 Write a firmware function get_factorial() that calculates the factorial of an unsigned integer. Print the result to the output. unsigned int get_factorial(unsigned int x); Determine how long it takes (in clock cycles) to perform the calculation !!\n\nExercise 105 Write a firmware function convert() that converts Temperature from Fahrenheit to degrees Celsius. The result may be rounded down. Print the result to the output. unsigned int convert(unsigned int x); Determine how long it takes (in clock cycles) to perform the calculation !!\n(0F âˆ’ 32) Ã— 5\u0026frasl;9 = -17,78\u0026nbsp;Â°C\n \n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/200_coprocessor/",
	"title": "2  Coprocessor",
	"tags": [],
	"description": "",
	"content": " Coprocessor Image courtesy: Pexels - Pixabay   div.image_courtesy { text-align: center; font-size: 100%; font-style: italic; }  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/200_coprocessor/201_coprocessor/",
	"title": "201 - Coprocessor",
	"tags": [],
	"description": "",
	"content": " All the code that you write has to be executed on the processor. With computers being ever more powerful, it is easy to forget about all the work a processor is doing. Irrespective of how simple a job might seem, it still needs to be executed. The example illustrates this. The only thing the processor needs to do is output 2 values. Nonetheless with the software as seen before, this takes 74 clock cycles.\n#include \u0026#34;print.h\u0026#34; void main(void) { print_str(\u0026#34;;\u0026#34;); print_str(\u0026#34;.\u0026#34;); } Offloading When a processor is doing a lot of work, it can become useful if parts of that work could be delegated or offloaded to another processor. Which portions of the work need to be offloaded ? What will the performance gain be ? What is the price (\u0026euro;s, area in silicon, energy, \u0026hellip; ) ? These are simple questions, but answering them is not straightforward !!\nThe first coprocessors saw the light of day in the 1970\u0026rsquo;s. It became clear that only doing calculations with integer numbers was to restrictive. The first coprocessors were floating-point units (FPUs). These coprocessor were so heavily used that their functionality got integrated in the processor itself.\nMultiplication The PicoRV32 implementation we\u0026rsquo;ve used so far only supports the RV32I instruction set. This means that only the basic integer operations are supported. Although the instruction set does not contain a multiplication operation, it can be used nonetheless.\n#include \u0026#34;print.h\u0026#34; void main(void) { volatile unsigned int value1, value2, product; value1 = 208; value2 = 3; product = value1 * value2; print_dec(product); } \nRunning this C-code generates an output .dat file. After parsing the output looks like this. 00000000000000000000000000110110 - 054 - 0x36 - 6 00000000000000000000000000110010 - 050 - 0x32 - 2 00000000000000000000000000110100 - 052 - 0x34 - 4 The value 624 is the product of the (hardcoded) values 208 and 3.\n\n\nThe reason that this works without having a mul instruction is because of the compiler jumps. The compiler figures out what needs to be done and comes up with a recipe to achieve what the code prescribes.\n00000174 \u0026lt;__mulsi3\u0026gt;: 174: 00050613 mv a2,a0 178: 00000513 li a0,0 17c: 0015f693 andi a3,a1,1 180: 00068463 beqz a3,188 \u0026lt;__mulsi3+0x14\u0026gt; 184: 00c50533 add a0,a0,a2 188: 0015d593 srli a1,a1,0x1 18c: 00161613 slli a2,a2,0x1 190: fe0596e3 bnez a1,17c \u0026lt;__mulsi3+0x8\u0026gt; 194: 00008067 ret   00000274 \u0026lt;main\u0026gt;: 274: fe010113 addi sp,sp,-32 278: 0d000793 li a5,208 27c: 00f12223 sw a5,4(sp) 280: 00300793 li a5,3 284: 00f12423 sw a5,8(sp) 288: 00412503 lw a0,4(sp) 28c: 00812583 lw a1,8(sp) 290: 00112e23 sw ra,28(sp) 294: ee1ff0ef jal ra,174 \u0026lt;__mulsi3\u0026gt;  \nChanging one letter in the Makefile allows the compiler use the mul instruction.\nARCHITECTURE = rv32i$(subst C,c,$(COMPRESSED_ISA)) to ARCHITECTURE = rv32im$(subst C,c,$(COMPRESSED_ISA)) \n00000168 \u0026lt;main\u0026gt;: 168: ff010113 addi sp,sp,-16 16c: 0d000793 li a5,208 170: 00f12223 sw a5,4(sp) 174: 00300793 li a5,3 178: 00f12423 sw a5,8(sp) 17c: 00412783 lw a5,4(sp) 180: 00812703 lw a4,8(sp) 184: 02e787b3 mul a5,a5,a4 188: 00f12623 sw a5,12(sp) 18c: 00c12503 lw a0,12(sp) 190: 01010113 addi sp,sp,16 194: f29ff06f j bc \u0026lt;print_dec\u0026gt;\n\n\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/200_coprocessor/202_pcpi/",
	"title": "202 - Pico CoProcessor Interface (PCPI)",
	"tags": [],
	"description": "",
	"content": " In Chapter 1 we\u0026rsquo;ve used the PicoRV32 implementation of a RISC-V. This implementation has a number of interfaces to the outside world. The memory interface was already discussed. In this section the Pico CoProcessor Interface (PCPI) is handled.\nMultiplication coprocessor To illustrate (the use of) a coprocessor, let\u0026rsquo;s take the multiplication. In the previous section it is illustrated how the compiler jumped in to achieve multiplication. Depending on the factors, this might take a lot time.\nThe PicoRV32 comes with an example multiplier in hardware. The design is shown in the image below.\n By now, most of the signals of the PCPI interface should make sense.\nControl path  pcpi_valid: a single bit signal that indicates the instruction is valid; pcpi_insn: a 32-bit instruction. This instruction is fetched by the PicoRV32 and handed over to the coprocessor (if needed); pcpi_ready: a single bit signal that indicates the coprocessor is done; pcpi_wait: a single bit signal that indicates the coprocessor needs more time; pcpi_wr: a single bit write enable signal to the PicoRV32.  Data path  pcpi_rs1: a 32-bit bus containing the first factor; pcpi_rs2: a 32-bit bus containing the second factor; pcpi_rd: a 32-bit bus containing the product;   \nConsulting the readme file of the PicoRV32 learns:\n the instruction that is implemented through the coprocessor should be non-branching; the pcpi_valid signal only goes on for unsupported instructions; the pcpi_insn, pcpi_rs1 and pcpi_rs2 fields are parsed by the PicoRV32; the PicoRV32 core can optionally decode the pcpi_rd field of the instruction and write the value from pcpi_rd to the respective register. When no external PCPI core acknowledges the instruction within 16 clock cycles, then an illegal instruction exception is raised and the respective interrupt handler is called. A PCPI core that needs more than a couple of cycles to execute an instruction, should assert pcpi_wait as soon as the instruction has been decoded successfully and keep it asserted until it asserts pcpi_ready. This will prevent the PicoRV32 core from raising an illegal instruction exception  If all of the above rules are obeyed (which they are in the example), the PicoRV32 can offload all the mul instructions to the coprocessor. This option should be enabled in the PicoRV32 through the parameters: ENABLE_PCPI and ENABLE_MUL.\npicorv32_inst00: component picorv32 generic map( ... ENABLE_PCPI =\u0026gt; \u0026#39;1\u0026#39;, ENABLE_MUL =\u0026gt; \u0026#39;1\u0026#39;, ... Balance Running the code above, with the coprocessor present, give the same result as the software-only variant. Lucky us !! ðŸ˜ƒ\nWhy should you go for one of both then ? That\u0026rsquo;s an important question and/or decision. To have some arguments in calling the shots, numbers can come in handy.\n    software only hardware + software     filesize of .elf file (bytes) 5\u0026rsquo;460 5\u0026rsquo;068   duration of program (CC) 467 404   required LUTs 897 1\u0026rsquo;205   required registers 574 868     the software only version needs more instruction memory. This makes sense as some additional, custom functions are generated to realise the multiplication. the version with the coprocessor finishes the job quicker. the software only version requires less configurable resources (on FPGA)   With these arguments, better-informed decisions can be made.\n If the available instruction memory is of the utmost importance, some hardware offloading might be useful. For applications where the cost is the most important feature, having fewer hardware coprocessors might be interesting.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/200_coprocessor/203_coproccesor_hd/",
	"title": "203 - Coprocessor example",
	"tags": [],
	"description": "",
	"content": " Coprocessor example As an example of a custom coprocessor a hardware component is made for calculating the Hamming distance.\nControl path The control path is made with a set-reset flipflop. The condition for setting is determined by the pcpi_valid signal and the instruction. Only if the opcode in pcpi_insn is 0110011 and the additional opcode field (funct7) is *0000001, this coprocessor is targeted.\nAs long as the set-reset-flipflop is turned on, the coprocessor keeps on working. The data width is set to 32 bits, so after 32 iterations the coprocessor needs to be stopped. This is achieved by having a 32-bit register shifting in zeroes. If only a single 1-bit is present in this register, the reset should be set. This guarantees that the set-reset flipflop will be turned off in the next clock cycle.\nWhile the coprocessor is running, the pcpi_wait signal is kept high. When the set-reset flipflop is reset, one clock cycle later (hence the register) the pcpi_ready and pcpi_wr signal should be high, for one clock period.\nData path Upon activation of the coprocessor both operands pcpi_rs1 and pcpi_rs2 are sampled. While the processor is running, these registers shift their values out. The XOR of both least significant bits serves as an increment signal to a counter register. This total count register is cleared upon activation and is written out through the pcpi_rd bus.\nCheating For this coprocessor to work, a dedicated instruction needs to be defined. Although this certainly is feasible, it is quite a cumbersome job. The compiler needs to be informed of the new instruction, which requires recompiling the cross-compiler.\nOne way to cheat our way around this is to reuse an existing instruction. The drawback of this approach is that this existing instruction can no longer be used with its original functionality.\nThe code below illustrates this cheat by abusing the mul instruction. This was already assumed in the hardware design with parsing the pcpi_insn.\nIn the C-code, an external function is used. This function has to unsigned integers as parameters and also returns an unsigned integer. As this function is not coded in this file, you need to inform the compiler that this function will be found during linking. This is achieved with the extern keyword.\n In the assembly, the hwswcd_hd() function is programmed. As you can see below, the only instruction this function does is the mul with registers a0 and a1 as operands.\nNote the line .global hwswcd_hd !! This symbol makes sure that the linker can find this function here.\n \nfirmware.c  #include \u0026#34;print.h\u0026#34; extern unsigned int hwswcd_hd(unsigned int value1, unsigned int value2); void main(void) { volatile unsigned int value1, value2, hd; value1 = 5; value2 = 9; hd = hwswcd_hd(value1, value2); print_str(\u0026#34;HD(0x\u0026#34;); print_hex(value1, 2); print_str(\u0026#34;, \u0026#34;); print_hex(value2, 2); print_str(\u0026#34;) = 0x\u0026#34;); print_hex(hd, 5); print_str(\u0026#34;.\u0026#34;); } \nstart.S \n.section .init .global main .global hwswcd_hd\nstart: /* zero-initialize all registers */ addi x1, zero, 0 addi x2, zero, 0 addi x3, zero, 0 addi x4, zero, 0 addi x5, zero, 0 addi x6, zero, 0 addi x7, zero, 0 addi x8, zero, 0 addi x9, zero, 0 addi x10, zero, 0 addi x11, zero, 0 addi x12, zero, 0 addi x13, zero, 0 addi x14, zero, 0 addi x15, zero, 0 addi x16, zero, 0 addi x17, zero, 0 addi x18, zero, 0 addi x19, zero, 0 addi x20, zero, 0 addi x21, zero, 0 addi x22, zero, 0 addi x23, zero, 0 addi x24, zero, 0 addi x25, zero, 0 addi x26, zero, 0 addi x27, zero, 0 addi x28, zero, 0 addi x29, zero, 0 addi x30, zero, 0 addi x31, zero, 0\n/* set stack pointer / lui sp, %hi(161024) addi sp, sp, %lo(16*1024)\n/* call main */ jal ra, main\n/* break - trap */ ebreak\nhwswcd_hd: mul a0, a0, a1 ret\n\n\nTadaaa You should be able to compile the binary with the code above. Don\u0026rsquo;t forget to target the RISC-V with the multiply extension (add \u0026rsquo;m\u0026rsquo;) The hardware modifications that need to be made are:\n instantiate the component pcpi_hwswcd_hd (and not the picorv32_pcpi_mul). enable the coprocessor interface ENABLE_PCPI =\u0026gt; '1' enable the multiplication ENABLE_MUL =\u0026gt; '1'  00000000000000000000000001001000 - 072 - 0x48 - H 00000000000000000000000001000100 - 068 - 0x44 - D 00000000000000000000000000101000 - 040 - 0x28 - ( 00000000000000000000000000110000 - 048 - 0x30 - 0 00000000000000000000000001111000 - 120 - 0x78 - x 00000000000000000000000000110000 - 048 - 0x30 - 0 00000000000000000000000000110101 - 053 - 0x35 - 5 00000000000000000000000000101100 - 044 - 0x2c - , 00000000000000000000000000100000 - 032 - 0x20 - 00000000000000000000000000110000 - 048 - 0x30 - 0 00000000000000000000000000111001 - 057 - 0x39 - 9 00000000000000000000000000101001 - 041 - 0x29 - ) 00000000000000000000000000100000 - 032 - 0x20 - 00000000000000000000000000111101 - 061 - 0x3d - = 00000000000000000000000000100000 - 032 - 0x20 - 00000000000000000000000000110000 - 048 - 0x30 - 0 00000000000000000000000001111000 - 120 - 0x78 - x 00000000000000000000000000110000 - 048 - 0x30 - 0 00000000000000000000000000110010 - 050 - 0x32 - 2 00000000000000000000000000101110 - 046 - 0x2e - . \n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/200_coprocessor/204_exercises/",
	"title": "204 - Exercises",
	"tags": [],
	"description": "",
	"content": " Exercise 201 Try to get the example for the Hamming distance to work.   Make a comparison like the table in 202 where you compare your pure software implementation of the Hamming distance with the codesign.  Exercise 202 Transform the Hamming distance coprocessor to work on the div instruction in stead of the mul instruction.  Exercise 203 Make a new coprocessor that calculates the average of two integer numbers. If the result is non-integer, round it down. For example avg(32,16) = 24 and avg(3,4) = 3. Try to avoid using the pcpi_wait signal. Compare a software-only version with a hardware/software codesign of the solution.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/300_soc/",
	"title": "3  System on Chip",
	"tags": [],
	"description": "",
	"content": " System on Chip (SOC) Image courtesy: Pexels - Pixabay   div.image_courtesy { text-align: center; font-size: 100%; font-style: italic; }  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/300_soc/301_busarchs/",
	"title": "301 - Bus architectures",
	"tags": [],
	"description": "",
	"content": " A SoC consists of more components than only a processor, as the name already implies. The system has multiple components depending on the task for which it was designed. Having multiple components like timers, interrupt controllers, or communication cores are very useful, unless they can\u0026rsquo;t be used. To achieve reachability, all the components must be connected through some bus architecture to the processor.\nA number of standardised bus architectures exist, for example:\n Wishbone Avalon AMBA CoreConnect  AMBA ARM has defined an open standard which allows the interconnection of such functional blocks: Advanced Microcontroller Bus Architecture (AMBA). Currently the fifth generation of the AMBA bus is available.\n p.image_courtesy { color: #7E7E7E; font-size: 14px; font-weight: 300; letter-spacing: -1px; padding-top: 0px; margin-top: -20px; text-align: center; }  image source: https://developer.arm.com/architectures/system-architectures/amba\nIt should not come as a surprise that the more recent versions are more powerful than the older ones, but they are also more complicated ðŸ˜ƒ. When working with design software like Xilinx\u0026rsquo;s Vivado, almost all components have an AXI4 interface. As the provided cores in such an ecosystem are all tuned towards a single standard, it becomes fairly easy for the designer to build a SoC. Two examples of how to use these buses in a system are shown in the images below.\n  \nTo protect ourselves from getting lost in details, only the APB bus will be used in this course. The most recent specification of this protocol can be obtained from the ARM website.\nAdvanced Peripheral Bus (APB) When two components are talking, typically the names master and slave are used. The lingo in the APB-bus uses: the requester and the completer. The image below shows a setup with one requester and one completer. The clock and reset signals are provided externally. Most of the signals are driven by the requester, but (offcourse) a couple of signals are driven by the completer.\nFor a more in-depth description of each of these signals, you can visit the specification.\nTransfers on the APB-bus follow 2 successive phases: the the setup phase and the access phase. In the setup phase the requester drives the SEL and the ADDR lines, amongst other. After one clock cycle the requester drives the ENABLE signal in the access phase.\nWrite transfer (without wait states)  Read transfer (without wait states)  \nThe examples above show the default write and read transfers. In the specification more detail (and explanation) is available, but putting these images right beside each other allows to better see the differences (and the similarities).\nFrom the images and the description it is clear that each transfer takes at least two clockcycles to complete. There you have the most important reason why the bus is mainly used for peripherals.\nThe peripherals that are connected through the APB bus typically use a register-interface. The idea behind this is that a peripheral has a number of registers that can be written and read by the processor. Based on the address map, read and write operations are handled by the targeted peripheral.\nPeripheral (overhead) Below is an example of a peripheral implementation. It contains NO functional block, but supports an APB interface. In the top-middle part are a number registers. These can be written and read by the requester. As with many other systems, there is a strobe signal. This allows you to mask (out) the 32-bit values with byte granularity.\nThe register in the top-right stores the data that is to be read. This register is loaded with one of the other register OR with another value (depicted by the small cloud in the closing curly bracket).\nAs all the peripherals are connected through a single APB bus, every peripheral must verify if a transfer is to be obeyed or not.\nThis example takes into account the following conditions to determine whether or not a transfer is targeted at this peripheral:   the address PADDR is larger than or equal to the base address (BA)  the address PADDR is smaller than or equal to the high address (HA)  the PSEL input is high  the PENABLE input is low (= setup phase)  When these conditions are met, the transfer is aimed at this peripheral. Depending on the PWRITE signal, the transfer is either a write (1) or a read (0) transfer.\nThe transfer that is considered for this peripheral (both in case of read or write) is sampled in one of the register on the bottom right. A simple OR of these registers can be used as the PREADY signal.\n  \n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/300_soc/302_counter/",
	"title": "302 - Counter peripheral",
	"tags": [],
	"description": "",
	"content": " When a hardware/software codesign is made, we need to be able to measure the performance. A simple way to achieve this, is counting how many clock cycles certain operations take. Later on, this shall be revisited, but the peripheral will be useful (pinky swear).\n Having a arrived at your Master year, a counter is not exactly rocket science, nor brain surgery. The simple design that is shown, is a counter that either be incremented or cleared.\nNote that this is not a special component, but a simple register with a load. The multiplexer and the adder add the functionality of a counter to the register.\n \nGluing things together The counter that is described above has two 1-bit inputs and one 32-bit output. If we want to control this counter from the processor, these signals should be writeable/readable by the processor. For this the register approach from the previous section is used. One single register is used to \u0026ldquo;direct\u0026rdquo; the functional block. Such a register is often referred to as a command register (CR).\nBy simply wiring (for example) the LSB of REG 0 to the increment input of the counter, a link is made. Similarly the bit at index (1) of REG 0 can be mapped to the clear input. With this configuration, writing to REG 0 controls the counter.\nThe CR could also be read back. This will come in handy. Next to reading the CR, reading back the value of the counter might be useful. Otherwise, the peripheral would be sort-of pointless.\nMemory map In earlier sections the memory was (briefly) discussed. As the SOC uses a 32-bit vector for addresses, this defines the memory space. The lowest addressable memory locations is 0x00000000 (aka zero), while the highest memory location is 0xFFFFFFFF (aka all foxes).\nThere is no doubt that you can write a program that takes 1\u0026rsquo;073\u0026rsquo;741\u0026rsquo;824 instructions (1 billion !!! Mind you, in Dutch this is \u0026ldquo;Ã©Ã©n miljard\u0026rdquo;). With SoCs it would be more realistic if the instruction memory is smaller than 4.3 TeraByte ðŸ˜ƒ. Typically the firmware indeed starts at address 0x0, but it is capped at a maximum.\n To allow you to write loads of code, it is assumed (for this course) that the instruction memory will never be larger than 0x7FFFFFFF addresses. The remainder of the available memory space is reserved for segmentation.\nThis leaves half of the memory space to allocate as we see fit. As an example the segment for this counter peripheral is placed at address 0x8F000000. In OS-lingo this is called the Base Address (BA). When we assign for example 1024 addresses for the counter, the High Address (HA) is 0x8F000FFF.\nYou might have noticed that the PicoRV32 has a parameter that sets the address of the stack pointer.\nparameter [31:0] STACKADDR = 32\u0026#39;h ffff_ffff  \n\nWith the memory map as described above, simply writing (in software) the value 1 to address 0x81000000, will enable the counter. Writing a value 0, will stop the counter. To clear the value of the counter a value of 2 has to be written to the CR.\nNote that a default write transfer writes 32 bits. Writing a value of 1 to the CR, will not only set the LSB to one, it also sets all other bits to zero !!  A default technique to set the bit with index 5 of CR, is to: 1) read the value of CR; 2)apply a mask so the 6th(!) bit is set, and 3) write back the result. This is the reason why it is also useful to be able to read back the value of CR.  CR |= (1\u0026lt;\u0026lt;5); /* clearing can we done with: CR \u0026amp;= ~(1\u0026lt;\u0026lt;5); */\n Double drivers One more thing to point out is double drivers. As you know, every gate can only be driven by a single source. The following scenario can be tempting.\nLet\u0026rsquo;s assume 2 registers for this APB counter functional block. One could be assigned as the CR and the other one can act as a status register (SR). In the example above this could be translate to REG 0 is CR and counter is SR.\nBe aware that the counter cannot be used in the same way as REG 0. It should either be writeable through the APB (or any) bus, or through some other part of the design.\nExample The example below shows a simulation. First, a write of the value 0x1 is done to address 0x81000000. This starts the counter. After a certain amount of time, a write of the value 0x0 is done to the same address. This stops the counter. Finally a read on address 0x81000004 is done to obtain the counter value.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/300_soc/303_soc/",
	"title": "303 - System on Chip (SoC)",
	"tags": [],
	"description": "",
	"content": " A system on a chip or SoC stands in contrast to the traditional PC or laptop which are organised around a motherboard. In the third Bachelor of this program an entire course was spent on this topic: System-on-Chip design and experimentation. If you need a refresher, please head over to the website.\nThe figure below shows an example of a SoC that we can build with what was seen before. At the hearth of the system is the RISC-V processor (picorv32i). The bus system that connects all the components together is an APB bus. Critical readers might point out the native memory interface of the picorv32i does not fit the APB-bus. A custom adapter is made to make this connection feasible (APB adapter). As you might have already spotted, the picorv32i already comes with two other adapters: 1 for connecting to an AXI bus, and 1 for converting to a wishbone interface.\nThe APB memory and the APB print components were already discussed. It is pointed out once more that both these components are actually models. The HDL code of these components is non-synthesisable, meaning: it\u0026rsquo;s valid HDL code, but it cannot be converted into hardware.\nFinally, the APB counter component was discussed in the previous page, and the APB dummy is simply a placeholder for any other core.\nMemory map One question that is not solved yet is how memory mapped IO (MMIO) is configured. To make live a bit easier (it\u0026rsquo;s already too complicated anyway ðŸ˜‰) the configuration is done in the package: PKG_hwswcodesign.\nPKG_hwswcodesign.vhd  ... constant C_BASE_ADDRESS_0 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;00000000\u0026#34;; constant C_HIGH_ADDRESS_0 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;00003FFF\u0026#34;; constant C_BASE_ADDRESS_1 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;80000000\u0026#34;; constant C_HIGH_ADDRESS_1 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;80000004\u0026#34;; constant C_BASE_ADDRESS_2 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;81000000\u0026#34;; constant C_HIGH_ADDRESS_2 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;81000FFF\u0026#34;; constant C_BASE_ADDRESS_3 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;81100000\u0026#34;; constant C_HIGH_ADDRESS_3 : STD_LOGIC_VECTOR(C_DATA_WIDTH-1 downto 0) := x\u0026#34;81100FFF\u0026#34;; ...  firmware.lds  SECTIONS { .memory : { . = 0x000000; *(.init); *(.text); *(*); . = ALIGN(4); end = .; } }   These constants set both the base address and the high address of the four components. Which values you choose here, is completely up to you. One traditional technique is to have the memory start at 0x0. This is also reflected in the linker-script (firmware.lds).\nEvery component gets its base address (BA) and high address (HA) configured through generics (or parameters for you .v people). The component can/could/should/may/\u0026hellip; check these limits to see whether or not communication is intended for them. The APB bus also checks this to determine if the component needs to be talked to or not. Don\u0026rsquo;t forget to make the correct modification on ALL (package, component, and APB-bus) locations if you want to modify the memory map.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/300_soc/304_exercises/",
	"title": "304 - Exercises",
	"tags": [],
	"description": "",
	"content": " Exercise 301 Try to get the example for the counter-enforced SoC to work.  Exercise 302 Make a new (as in: don't modify the dummy) component that can calculated the Hamming distance of two values.   Make a comparison like the table in 202 where you compare your pure software implementation of the Hamming distance with the codesign.  Exercise 303 Make a new component that calculates the sine of a positive angle. The angle is provided as natural number (no decimals), in degrees and can be up to 10 bits.   To prevent decimal numbers, the resulting value should be multiplied with 1'000'000. The remaining decimal digits can be dropped. Hence the result should fit in 20 bits.   Negative numbers should be represented in two's complement. Some examples: PROTIP: work smart, not hard !!  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/400_interrupt/",
	"title": "4  Interrupt",
	"tags": [],
	"description": "",
	"content": " Interrupt Image courtesy: Pexels - Pavel Danilyuk   div.image_courtesy { text-align: center; font-size: 100%; font-style: italic; }  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/400_interrupt/401_interrupt/",
	"title": "401 - Interrupt",
	"tags": [],
	"description": "",
	"content": " In the beginning of the processor-age, all software was bare metal. This means that the processor is simply executing instructions, directly on the hardware. In contrast to bare metal, most computers nowadays run an operating system. However, many microcontrollers still run bare-metal-code. Everything that we have been doing, was bare metal, too.\nMultiple tasks When operating without an OS, it becomes more difficult to run multiple tasks. Let\u0026rsquo;s take the example of a UART, aka the serial port. Imagine a program is running and it has to change a parameter that is fed to program over UART.\n Polling The simplest way would be to periodically check if there is a command. Periodically checking for a condition is called polling.\nIn this example, the main loop is running forever. The program conditionally takes one of two paths (an if-statement). In the left-hand branch, there is a repetition (a for or while loop). Finally, there is one more statement.\nDepending on the fact whether or not there is a new command, the left or right path is taken to the start of the loop again. Let\u0026rsquo;s say that, in case of a new command, the 3 yellow statements have to be executed.\nAlthough polling provides a working solution, it\u0026rsquo;s not the best solution. There is a additional delay (in this case of 1 if-statement), if a command arrives right after the checking, it has to wait for the next iteration, \u0026hellip;\n \nInterrupts In 1953 (!) the first interrupt-powered computer was invented. An interrupt does exactly what it is named after. It interrupts the current flow of the processor. A good analogy is the raising of a finger, in class.\nThe example above would just keep on executing the main loop. Irrespective of when the UART comes now, this main loop is interrupted. After interruption, the three yellow statements are executed. Finally, the main loop is resumed at the point where it was left.\nAs long as there are no interrupt storms, the impact of interrupts is low. They are still used in modern systems and the typical use-cases are asynchronous communication systems, like network cards, mouse movements, timers, or keyboard-key presses.\n  \n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/400_interrupt/402_handling/",
	"title": "402 - Interrupt handling",
	"tags": [],
	"description": "",
	"content": " Interrupts can be generated by both hardware and software, but hardware-interrupts are focussed on here. A processor typically has a number of hardware interrupts. These signals are connected to the cores that generate interrupts.\nWhen a core wants to signal an interruption, it raises the signal. This is called an Interrupt Request (IRQ). The processor has to halt its operation, to the interrupt can be handled. However, the processor has a context. There are values in the registers and the stack pointer and program counter are set to a certain value. Before the processor can drop what it\u0026rsquo;s doing, a backup of this context has to be made.\nAfter backing up the context, the processor runs some software code that handles the IRQ. This small piece of software code is the interrupt handler or interrupt service routine (ISR). It\u0026rsquo;s trivial that, after the execution of the ISR, the backed-up context needs to be restored.\nInterrupt service routines should not take too long to run. After all, the complete system is waiting for it\u0026rsquo;s end, before it can continue.\nFor the sake of completeness it is mentioned that interrupts can also be nested, as in: an interrupt during the execution of an ISR. Typically, there is a hierarchy that decides which IRQ has priority.\n Interrupts and PicoRV32 The RISC-V implementation of the PicoRV32 allows the usage of interrupts, albeit not entirely according to the RISC-V specifications.\n The IRQ handling features in PicoRV32 do not follow the RISC-V Privileged ISA specification. Instead a small set of very simple custom instructions is used to implement IRQ handling with minimal hardware overhead.\n To use interrupts with the PicoRV32, the generic ENABLE_IRQ needs to be enabled. This enables the use of the 32-bit irq input that provides the IRQs. When an interrupt is getting handled, the PicoRV32 signals this by raising the corresponding eoi (end of interrupt) signal. When the interrupt is handled, this signal is dropped.\nThis all looks nice-and-simple, but there are quite some things going on under the hood.\nWhere to start (with our implementation)? The first parameter we can look at is where to processor starts running code. Until now, the objectdump look something like shown here. At address 0x00000000 the \u0026nbsp;initialisation\u0026nbsp; was done. This code came from the start.S file and it initialises all 32 register to 0x0, sets the stack pointer (sp), and jumps to the main function.\nSubsequently, the \u0026nbsp;functions\u0026nbsp; are place in the memory space. Every function that is required in the program is put sequentially.\nFinally, the \u0026nbsp;main\u0026nbsp; function is positioned. Typically, the main function never exits. There some outer loop that keeps on running. In case the main function would exit, the processor goes back to which ever function called the main function. In our case, this is the start. The only thing the start does, in this case, is stopping the processor with the ebreak command.\nAt the highest address (of the allocated memory space) the stack is put. As a reminder, the stack grow in the opposite direction, when required.\n  \n When adding the interrupt functionality we have to define some more sections.\nThe start of the program is placed in the \u0026nbsp;reset vector\u0026nbsp;. This section acts a sort of boot-loader. The absolute minimum of settings is done, after which a jump to the \u0026nbsp;start\u0026nbsp; is made. A frequently used technique is restrict the size of the reset_vector. This ensures that the next section (the interrupt vector) can start at a fixed memory position, irrespective of the length of the start.\nThe \u0026nbsp;interrupt handler\u0026nbsp; section holds the assembly-code that is responsible for the backing-up and restoring of the context. Of course, between the backup and restore of the context, the interrupt service routine should be called. Another sections that has to be defined is that of the location where the context may be stored: \u0026nbsp;interrupt registers\u0026nbsp;.\nFinally, also the interrupt handling can make use of a stack. This \u0026nbsp;interrupt stack\u0026nbsp; is independent of the normal stack.\nNote that the addition of these sections, doesn\u0026rsquo;t affect the \u0026nbsp;main\u0026nbsp; other than a relocation of its starting address.\n \nHow to reach? As can be seen from the image above, there is one arrow that connects the left hand portion to the right hand portion. With this observation, it can be asked HOW the processor switches back from right to left? The component that takes care of this is processor itself. There has to be some hardware block that allow for interrupts. If an irq arrives, the program counter is automatically set the interrupt vector.\nYou might have already noticed when instantiating the PicoRV32, there are some generics/parameters that have to be set. The PROGADDR_RESET is a 32-bit vector that defines the address at which the processor has to start running, after reset: the \u0026nbsp;reset vector\u0026nbsp;. In the example above, this is kept at the default: 0x00000000. Next there is the PROGADDR_IRQ which is a 32-bit vector that defines the start address of the \u0026nbsp;interrupt handler\u0026nbsp;. This, also, is kept at its default value: 0x00000010.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/400_interrupt/403_example/",
	"title": "403 - Example",
	"tags": [],
	"description": "",
	"content": " This page gives a hands-on example of using interrupts with the PicoRV32.\nHARDWARE RISC-V instantiation At the instantiation, the following additional mappings need to be made:\n ENABLE_IRQ \u0026hellip; to \u0026lsquo;1\u0026rsquo; ENABLE_IRQ_QREGS \u0026hellip; to \u0026lsquo;1\u0026rsquo; ENABLE_IRQ_TIMER \u0026hellip; to \u0026lsquo;1\u0026rsquo; MASKED_IRQ \u0026hellip; to x\u0026rdquo;00000000\u0026rdquo; LATCHED_IRQ \u0026hellip; to x\u0026rdquo;FFFFFFFF\u0026rdquo; PROGADDR_RESET \u0026hellip; to x\u0026rdquo;00000000\u0026rdquo; PROGADDR_IRQ \u0026hellip; to x\u0026rdquo;00000010\u0026rdquo;  These settings:\n enable the IRQ ensures the IRQs are not masked-out set the reset vector set the IRQ handler  Interrupts can be given through signal irq, and the ack\u0026rsquo;s come at the eoi signal.\n  \nSOFTWARE PicoRV32 custom instructions The PicoRV32 has a handful of custom instructions. To make the assembly-code (a bit) more readable some custom instructions and register-names have been defined. These can be found in custom_ops.S from the PicoRV32 Github repository.\n picorv32_getq_insn(): copy q-register to gp-register picorv32_setq_insn(): copy gp-register to q-register picorv32_retirq_insn(): return from interrupt and re-enable interrupts picorv32_maskirq_insn(): write a new value to the irq mask register and reads the old value (The \u0026ldquo;IRQ Mask\u0026rdquo; register contains a bitmask of masked (disabled) interrupts). picorv32_waitirq_insn(): pause execution until an interrupt becomes pending picorv32_timer_insn(): reset the timer counter to a new value.  More info here.\n Reset vector The start.S assembly file that has been used up until now, needs to be extended.\nreset_vec: // no more than 16 bytes here !  // enable all interrupts  picorv32_maskirq_insn(zero, zero) // jump to start function  j start \n The reset vector can not contain more than 16 instructions. Otherwise, exceeding the 0x10 offset of the PROGADDR_IRQ, will overwrite the IRQ vector. All the interrupts are enabled (by setting their mask-value to zero). A jump to \u0026nbsp;start\u0026nbsp; is made. \n\n\nInterrupt handler The start.S assembly file that has been used up until now, needs to be extended some more.\n.balign 16 irq_vec: /* save registers, by copying through x1 and x2 */ picorv32_setq_insn(q2, x1) picorv32_setq_insn(q3, x2) lui x1, %hi(irq_regs) addi x1, x1, %lo(irq_regs) picorv32_getq_insn(x2, q0) sw x2, 0*4(x1) picorv32_getq_insn(x2, q2) sw x2, 1*4(x1) picorv32_getq_insn(x2, q3) sw x2, 2*4(x1) sw x3, 3*4(x1) sw x4, 4*4(x1) sw x5, 5*4(x1) sw x6, 6*4(x1) sw x7, 7*4(x1) sw x8, 8*4(x1) sw x9, 9*4(x1) sw x10, 10*4(x1) sw x11, 11*4(x1) sw x12, 12*4(x1) sw x13, 13*4(x1) sw x14, 14*4(x1) sw x15, 15*4(x1) sw x16, 16*4(x1) sw x17, 17*4(x1) sw x18, 18*4(x1) sw x19, 19*4(x1) sw x20, 20*4(x1) sw x21, 21*4(x1) sw x22, 22*4(x1) sw x23, 23*4(x1) sw x24, 24*4(x1) sw x25, 25*4(x1) sw x26, 26*4(x1) sw x27, 27*4(x1) sw x28, 28*4(x1) sw x29, 29*4(x1) sw x30, 30*4(x1) sw x31, 31*4(x1) /* call interrupt handler C function */ lui sp, %hi(irq_stack) addi sp, sp, %lo(irq_stack) /* arg0 = address of regs */ lui a0, %hi(irq_regs) addi a0, a0, %lo(irq_regs) /* arg1 = interrupt type */ picorv32_getq_insn(a1, q1) /* call to C function */ jal ra, irq /* restore registers */ /* new irq_regs address returned from C code in a0 */ addi x1, a0, 0 lw x2, 0*4(x1) picorv32_setq_insn(q0, x2) lw x2, 1*4(x1) picorv32_setq_insn(q1, x2) lw x2, 2*4(x1) picorv32_setq_insn(q2, x2) lw x3, 3*4(x1) lw x4, 4*4(x1) lw x5, 5*4(x1) lw x6, 6*4(x1) lw x7, 7*4(x1) lw x8, 8*4(x1) lw x9, 9*4(x1) lw x10, 10*4(x1) lw x11, 11*4(x1) lw x12, 12*4(x1) lw x13, 13*4(x1) lw x14, 14*4(x1) lw x15, 15*4(x1) lw x16, 16*4(x1) lw x17, 17*4(x1) lw x18, 18*4(x1) lw x19, 19*4(x1) lw x20, 20*4(x1) lw x21, 21*4(x1) lw x22, 22*4(x1) lw x23, 23*4(x1) lw x24, 24*4(x1) lw x25, 25*4(x1) lw x26, 26*4(x1) lw x27, 27*4(x1) lw x28, 28*4(x1) lw x29, 29*4(x1) lw x30, 30*4(x1) lw x31, 31*4(x1) picorv32_getq_insn(x1, q1) picorv32_getq_insn(x2, q2) picorv32_retirq_insn() \nAs a reminder:\n register x0 contains a hard-wired value of 0x00000000 register x1 contains the return address register x2 contains the stack pointer (sp) register x3 is for general purpose (gp) register x4 contains the thread pointer (tp)   First of all, it has to be made sure that the interrupt handler starts at address 0x00000010. This can be done with .balign 16.\nNext, the copying of the state has to be done. All the copies need to be made to the \u0026nbsp;interrupt registers\u0026nbsp;. This happens in these steps:\n backup of registers x1 and x2  backup registers x1 and x2 to q2 and q3 load the address of \u0026nbsp;interrupt registers\u0026nbsp; in x1 copy registers q0, q2 and q3 to \u0026nbsp;interrupt registers\u0026nbsp; by using relative addressing (offsets against the value that is stored in x1), through x2  backup of registers x3 .. x31  copy the registers to \u0026nbsp;interrupt registers\u0026nbsp; by using relative addressing (offsets against the value that is stored in x1), through x2   When everything is safely backed up, it\u0026rsquo;s time to call the actual instructions for handling the interrupt. This is a C-function:\nuint32_t *irq(uint32_t *regs, uint32_t irqs) Before a call to this function can be made, the stack pointer (sp) is changed to use the \u0026nbsp;interrupt stack\u0026nbsp;.\nThe two arguments that are passed to the irq function need to be stored in a0 and a1. These arguments are set, prior to performing the jump-and-link to the actual function.\nThe restore of the state is done in a similar fashion as the backup. When everything is tidied up, the \u0026lsquo;return-from-interrupt\u0026rsquo; function is called: picorv32_retirq_insn().\n\n\nThe actual C-code for the interrupt handler can be downloaded from the PicoRV32 Github repository (irq.c).\nInterrupt registers irq_regs: // registers are saved to this memory region during interrupt handling  // the program counter is saved as register 0  .fill 32,4 \nInterrupt stack\n// stack for the interrupt handler  .fill 128,4 irq_stack: \n\nSimulation With these modifications to hardware and software, the simulation should be able to show the working, interrupt-able processor.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/400_interrupt/404_exercises/",
	"title": "404 - Exercises",
	"tags": [],
	"description": "",
	"content": " Exercise 401 Try to get the example to work.  Exercise 402 Determine how much time it takes for handling a single interrupt.  Exercise 403 Start from the example of the counter in [302](http://localhost:1313/hwswcodesign-course/300_soc/302_counter/). Have the peripheral trigger an interrupt when the count reaches **100'000'000**. Given that a clock cycle takes 10 ns. an interrupt should be triggered every (10 ns/CC x 100'000'000 CC) second. Meanwhile the processor is in an endless loop that prints something. When the interrupt comes, handle it accordingly and reset the counter.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/500_ascon/",
	"title": "5 ASCON",
	"tags": [],
	"description": "",
	"content": " ASCON "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/500_ascon/501_ascon/",
	"title": "501 ASCON",
	"tags": [],
	"description": "",
	"content": " ASCON is a cryptographic scheme. It was chosen as the winning candidate in NIST\u0026rsquo;s \u0026ldquo;Lightweight Cryptography\u0026rdquo;-competition. This announcement was made on February 7th, 2023.\nCandidates that were submitted to this competition needed to have these two functionalities: authenticated encryption and hashing. For the project in this course, you\u0026rsquo;ll be making a SW-only and a HW/SW implementation of the hashing functionality. The complete specifications for ASCON can be found here.\nHashing A hash function is a one-way function that generates a message of fixed length, from an input of an arbitrary length. (Have some fun on: this site, if you wanna play around a bit).\nBy definition:\n there will always be collisions even the tiniest change in the input, should result in a completely different hash digest (avalanche property)  Sponge-construction When the ASCON hash digest of a message is to be calculated, the input is split in blocks of r bits. The rate ( r ) is, by default, 64 bits. Every r-bit block is absorbed by the sponge. The hash implementation keeps an internal state which is 320 bits wide. This internal state is manipulated and updated for each of the input blocks. The remaining (320 - r) = 256 bits is called the capacity ( c ).\nOnce all the input blocks are absorbed, it is time to squeeze out the digest. The default width of this digest is 256 bits and it is squeezed out in 4 operations which produce 64 bits (= r ) each.\nFor every hash calculation, the internal state is initialised by concatenating the following values:\n eight \u0026lsquo;0\u0026rsquo;-bits the size of the rate r, expressed in 1 byte the round number a, expressed in 1 byte the difference in round numbers a-b, expressed in 1 byte the size of the digest, expressed in 4 bytes  This constant is: 0x00400c0000000100. The remainder of the internal state is filled with \u0026lsquo;0\u0026rsquo;-bits.\nNote that the message is ALWAYS padded. The message is padded with a binary \u0026lsquo;1`, followed by a number of zeroes to create a message length that is a multiple of 64 bits.\n Permutation A lot of cryptographic algorithms use some sort of permutation function. Although a permutation is a shuffle of a set of elements, this is not what the permutation does in many of these algorithms.\nThe permutation in ASCON consists of 3 different steps:\n pC: this step takes a 320-bit input and EXORs it with a round-dependant constant. The result, again, is 320 bits. pS: this step takes a 320-bit input and substitutes sets of 5 bits with 5 different bits. The result, again, is 320 bits. pL: this step takes a 320-bit input and diffuses the results over the state. The result, again, is 320 bits.  A full permutation p consists of p = pL \u0026compfn; pS \u0026compfn; pC.\nA permutation as it is used in ASCON consists of a number of rounds. This means that the input is pulled through the 3 steps multiple times. The scheme provides 2 different round numbers: a and b. For the ASCON-hash function, both a and b are set to 12.\n Image courtesy: Pexels - Anna Shvets \n div.image_courtesy { text-align: center; font-size: 100%; font-style: italic; }   \nPC\n OR PS\n PL\n \nAnother visualisation of the same steps in the permutation is this:\nTestvectors An indispensable piece of information for this sort of work is a set of testvectors. These can be found here.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/500_ascon/502_profiling/",
	"title": "502 Profiling",
	"tags": [],
	"description": "",
	"content": " In the first step of the project, a software implementation of ASCON hash is to be made. The prototype of the hash function should look like this:\nvoid ascon_hash(uint32_t * digest, uint32_t * message, uint8_t mlen);  the first argument contains a pointer to the reserved memory in which the digest will be saved; the second argument contains a pointer to the first memory address on which the message is saved; the third and final argument is an unsigned byte that gives the length of the message in number of 32-bit words.  This function, ascon_hash( ), will hence be called once for each hash operation. It might very well be that you create a number of other functions to achieve a working implementation.\nHaving an insight in how often each function is called, can be interesting information for choosing the most optimal point for hardware offloading. This can be done with profiling\nAn example #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt; void orden_two(uint8_t * a, uint8_t * b); void orden_list(uint8_t * l); uint8_t check_list(uint8_t * l); void print_list(uint8_t * l); uint8_t main(void) { uint8_t list[] = {3, 6, 1, 8, 2, 0, 5, 4, 9, 7}; uint8_t rv; print_list(list); rv = check_list(list); while(rv \u0026gt; 0) { orden_list(list); print_list(list); rv = check_list(list); } return 0; } void orden_two(uint8_t * a, uint8_t * b) { uint8_t temp; if(*a \u0026gt; *b) { temp = *a; *a = *b; *b = temp; } } void orden_list(uint8_t * l) { for(uint8_t i=0;i\u0026lt;9;i++) { orden_two(\u0026amp;l[i], \u0026amp;l[i+1]); } } uint8_t check_list(uint8_t * l) { for(uint8_t i=0;i\u0026lt;9;i++) { if(l[i] \u0026gt; l[i+1]) { return 1; }} return 0; } void print_list(uint8_t * l) { for(uint8_t i=0;i\u0026lt;10;i++) { printf(\u0026#34;%i \u0026#34;, l[i]); } printf(\u0026#34;\\n\u0026#34;); } \nBubble sort\nLet\u0026rsquo;s look at this example. It performs a bubble-sort operation on a list of 10 unsigned bytes.\nThe list is first printed, after which it is checked whether or not further sorting is required. If required, the list is ordened again.\nThe ordening happens by iterating over the array, per couple of entries. These entries possibly switch locations (if required).\nCompiling Now \u0026hellip; to see where optimisation would pay of most we run profiling on this code. The gprof tool comes with the gcc compiler. To enable profiling, the compile option -pg needs to be added.\ngcc -o main_v1 main_v1.c becomes\ngcc -pg -o main_v1 main_v1.c Running After running the executable, an additional (binary) file is created: gmon.out. This file contains metadata that is stored during the running of the executable.\nTo parse the gmon.out file, simply run the command again, preceded by gprof. To store the output, the standard output can be redirected to a file (bash \u0026gt; analysis.txt).\n./main_v1 .gprof /main_v1 \u0026gt; analysis_v1.txt \n\nBelow you can see te result of the outcome. For more information on the gprof tool, see the man page.\nProfile v1 In v1, list is initialised with:\nuint8_t list[] = {3, 6, 1, 8, 2, 0, 5, 4, 9, 7}; Flat profile: Each sample counts as 0.01 seconds. no time accumulated % cumulative self self total time seconds seconds calls Ts/call Ts/call name 0.00 0.00 0.00 45 0.00 0.00 orden_two 0.00 0.00 0.00 6 0.00 0.00 check_list 0.00 0.00 0.00 6 0.00 0.00 print_list 0.00 0.00 0.00 5 0.00 0.00 orden_list % the percentage of the total running time of the time program used by this function. cumulative a running sum of the number of seconds accounted seconds for by this function and those listed above it. self the number of seconds accounted for by this seconds function alone. This is the major sort for this listing. calls the number of times this function was invoked, if this function is profiled, else blank. self the average number of milliseconds spent in this ms/call function per call, if this function is profiled, else blank. total the average number of milliseconds spent in this ms/call function and its descendents per call, if this function is profiled, else blank. name the name of the function. This is the minor sort for this listing. The index shows the location of the function in the gprof listing. If the index is in parenthesis it shows where it would appear in the gprof listing if it were to be printed. Copyright (C) 2012-2020 Free Software Foundation, Inc. Copying and distribution of this file, with or without modification, are permitted in any medium without royalty provided the copyright notice and this notice are preserved. Call graph (explanation follows) granularity: each sample hit covers 2 byte(s) no time propagated index % time self children called name 0.00 0.00 45/45 orden_list [4] [1] 0.0 0.00 0.00 45 orden_two [1] ----------------------------------------------- 0.00 0.00 6/6 main [10] [2] 0.0 0.00 0.00 6 check_list [2] ----------------------------------------------- 0.00 0.00 6/6 main [10] [3] 0.0 0.00 0.00 6 print_list [3] ----------------------------------------------- 0.00 0.00 5/5 main [10] [4] 0.0 0.00 0.00 5 orden_list [4] 0.00 0.00 45/45 orden_two [1] ----------------------------------------------- This table describes the call tree of the program, and was sorted by the total amount of time spent in each function and its children. Each entry in this table consists of several lines. The line with the index number at the left hand margin lists the current function. The lines above it list the functions that called this function, and the lines below it list the functions this one called. This line lists: index A unique number given to each element of the table. Index numbers are sorted numerically. The index number is printed next to every function name so it is easier to look up where the function is in the table. % time This is the percentage of the `total\u0026#39; time that was spent in this function and its children. Note that due to different viewpoints, functions excluded by options, etc, these numbers will NOT add up to 100%. self This is the total amount of time spent in this function. children This is the total amount of time propagated into this function by its children. called This is the number of times the function was called. If the function called itself recursively, the number only includes non-recursive calls, and is followed by a `+\u0026#39; and the number of recursive calls. name The name of the current function. The index number is printed after it. If the function is a member of a cycle, the cycle number is printed between the function\u0026#39;s name and the index number. For the function\u0026#39;s parents, the fields have the following meanings: self This is the amount of time that was propagated directly from the function into this parent. children This is the amount of time that was propagated from the function\u0026#39;s children into this parent. called This is the number of times this parent called the function `/\u0026#39; the total number of times the function was called. Recursive calls to the function are not included in the number after the `/\u0026#39;. name This is the name of the parent. The parent\u0026#39;s index number is printed after it. If the parent is a member of a cycle, the cycle number is printed between the name and the index number. If the parents of the function cannot be determined, the word `\u0026lt;spontaneous\u0026gt;\u0026#39; is printed in the `name\u0026#39; field, and all the other fields are blank. For the function\u0026#39;s children, the fields have the following meanings: self This is the amount of time that was propagated directly from the child into the function. children This is the amount of time that was propagated from the child\u0026#39;s children to the function. called This is the number of times the function called this child `/\u0026#39; the total number of times the child was called. Recursive calls by the child are not listed in the number after the `/\u0026#39;. name This is the name of the child. The child\u0026#39;s index number is printed after it. If the child is a member of a cycle, the cycle number is printed between the name and the index number. If there are any cycles (circles) in the call graph, there is an entry for the cycle-as-a-whole. This entry shows who called the cycle (as parents) and the members of the cycle (as children.) The `+\u0026#39;recursive calls entry shows the number of function calls that were internal to the cycle, and the calls entry for each member shows, for that member, how many times it was called from other members of the cycle. Copyright (C) 2012-2020 Free Software Foundation, Inc. Copying and distribution of this file, with or without modification, are permitted in any medium without royalty provided the copyright notice and this notice are preserved. Index by function name [2] check_list [1] orden_two [4] orden_list [3] print_list \nProfile v2 In v2, list is initialised with:\nuint8_t list[] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}; Flat profile: Each sample counts as 0.01 seconds. no time accumulated % cumulative self self total time seconds seconds calls Ts/call Ts/call name 0.00 0.00 0.00 81 0.00 0.00 orden_two 0.00 0.00 0.00 10 0.00 0.00 check_list 0.00 0.00 0.00 10 0.00 0.00 print_list 0.00 0.00 0.00 9 0.00 0.00 orden_list % the percentage of the total running time of the time program used by this function. cumulative a running sum of the number of seconds accounted seconds for by this function and those listed above it. self the number of seconds accounted for by this seconds function alone. This is the major sort for this listing. calls the number of times this function was invoked, if this function is profiled, else blank. self the average number of milliseconds spent in this ms/call function per call, if this function is profiled, else blank. total the average number of milliseconds spent in this ms/call function and its descendents per call, if this function is profiled, else blank. name the name of the function. This is the minor sort for this listing. The index shows the location of the function in the gprof listing. If the index is in parenthesis it shows where it would appear in the gprof listing if it were to be printed. Copyright (C) 2012-2020 Free Software Foundation, Inc. Copying and distribution of this file, with or without modification, are permitted in any medium without royalty provided the copyright notice and this notice are preserved. Call graph (explanation follows) granularity: each sample hit covers 2 byte(s) no time propagated index % time self children called name 0.00 0.00 81/81 orden_list [4] [1] 0.0 0.00 0.00 81 orden_two [1] ----------------------------------------------- 0.00 0.00 10/10 main [10] [2] 0.0 0.00 0.00 10 check_list [2] ----------------------------------------------- 0.00 0.00 10/10 main [10] [3] 0.0 0.00 0.00 10 print_list [3] ----------------------------------------------- 0.00 0.00 9/9 main [10] [4] 0.0 0.00 0.00 9 orden_list [4] 0.00 0.00 81/81 orden_two [1] ----------------------------------------------- This table describes the call tree of the program, and was sorted by the total amount of time spent in each function and its children. Each entry in this table consists of several lines. The line with the index number at the left hand margin lists the current function. The lines above it list the functions that called this function, and the lines below it list the functions this one called. This line lists: index A unique number given to each element of the table. Index numbers are sorted numerically. The index number is printed next to every function name so it is easier to look up where the function is in the table. % time This is the percentage of the `total\u0026#39; time that was spent in this function and its children. Note that due to different viewpoints, functions excluded by options, etc, these numbers will NOT add up to 100%. self This is the total amount of time spent in this function. children This is the total amount of time propagated into this function by its children. called This is the number of times the function was called. If the function called itself recursively, the number only includes non-recursive calls, and is followed by a `+\u0026#39; and the number of recursive calls. name The name of the current function. The index number is printed after it. If the function is a member of a cycle, the cycle number is printed between the function\u0026#39;s name and the index number. For the function\u0026#39;s parents, the fields have the following meanings: self This is the amount of time that was propagated directly from the function into this parent. children This is the amount of time that was propagated from the function\u0026#39;s children into this parent. called This is the number of times this parent called the function `/\u0026#39; the total number of times the function was called. Recursive calls to the function are not included in the number after the `/\u0026#39;. name This is the name of the parent. The parent\u0026#39;s index number is printed after it. If the parent is a member of a cycle, the cycle number is printed between the name and the index number. If the parents of the function cannot be determined, the word `\u0026lt;spontaneous\u0026gt;\u0026#39; is printed in the `name\u0026#39; field, and all the other fields are blank. For the function\u0026#39;s children, the fields have the following meanings: self This is the amount of time that was propagated directly from the child into the function. children This is the amount of time that was propagated from the child\u0026#39;s children to the function. called This is the number of times the function called this child `/\u0026#39; the total number of times the child was called. Recursive calls by the child are not listed in the number after the `/\u0026#39;. name This is the name of the child. The child\u0026#39;s index number is printed after it. If the child is a member of a cycle, the cycle number is printed between the name and the index number. If there are any cycles (circles) in the call graph, there is an entry for the cycle-as-a-whole. This entry shows who called the cycle (as parents) and the members of the cycle (as children.) The `+\u0026#39;recursive calls entry shows the number of function calls that were internal to the cycle, and the calls entry for each member shows, for that member, how many times it was called from other members of the cycle. Copyright (C) 2012-2020 Free Software Foundation, Inc. Copying and distribution of this file, with or without modification, are permitted in any medium without royalty provided the copyright notice and this notice are preserved. Index by function name [2] check_list [1] orden_two [4] orden_list [3] print_list \n\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/500_ascon/503_project/",
	"title": "503 ASCON project",
	"tags": [],
	"description": "",
	"content": "As it is an official holiday, there is no lesson on May first. However it will be the deadline for the first part of the project.\nThe first part is a pure software implementation of ASCON hash. The functionality should be triggered upon this function:\nvoid ascon_hash(uint32_t * digest, uint32_t * message, uint8_t mlen);  The maximum value for length is 255. This means that the input can be 255 x 32 bits = 8160 bits which is 1020 bytes. All parameters (rate, capacity, \u0026hellip;) are the default numbers.  For this first part the C-code has to be uploaded to toledo, together with your self-defined optimalisation targets (in a simple text file).\n The second part is a hardware/software co-design of ASCON hash. You can choose your own optimalisation-targets (smaller area, smaller binary size, bigger throughput, \u0026hellip;) and you have unlimited budget (with respect to resources).\n   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/900_appendices/",
	"title": "9 Appendices",
	"tags": [],
	"description": "",
	"content": " Appendices "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/900_appendices/901_roger/",
	"title": "901 - Roger",
	"tags": [],
	"description": "",
	"content": " Within the Engineering Technology program it is sometimes needed to have access to a server. For the purpose, Roger was born.\nThis server is accessible over the Internet through SSH. You have received (or will receive) an email that contains your username and password.\nSSH-ing To connect to Roger, an SSH client should be used (e.g. putty). In case a GUI will be used, an Xserver should be run on your machine. MobaXterm is a tool that provides both an SSH client and an Xserver.\nLog in on Roger which lives at 193.190.58.21 on port 2222 with your login and change your password.\n [jovliegen@roger ~]$ passwd\n Makefile for cross compiling In the Makefile of the example (found here), the cross compiler is set like this:\n RISCV_GNU_TOOLCHAIN_INSTALL_PREFIX = /opt/riscv32\nTOOLCHAIN_PREFIX = $(RISCV_GNU_TOOLCHAIN_INSTALL_PREFIX)i/bin/riscv32-unknown-elf-\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/",
	"title": "HWSW codesign",
	"tags": [],
	"description": "",
	"content": " HW/SW codesign Image courtesy: Pexels - DS stories   div.image_courtesy { text-align: center; font-size: 100%; font-style: italic; }  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_hwswcodesign/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]